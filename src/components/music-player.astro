---
import TitleDisplay from "./music-player/title-display.astro";
import PlayControl from "./music-player/play-control.astro";
import VolumeControl from "./music-player/volume-control.astro";
import TempoControl from "./music-player/tempo-control.astro";
---

<music-player>
  <audio src="5-seconds-of-silence.mp3" loop></audio>
  <TitleDisplay class="title-display" />
  <PlayControl class="play-control" />
  <div class="volume-and-tempo">
    <VolumeControl class="volume-control" />
    <TempoControl class="tempo-control" />
  </div>
</music-player>

<script>
  import type { Music } from "../models/music";
  import { queryMusicTabulizer } from "../utils/query";
  import { MediaSessionController } from "./music-player/_helpers/media-session";
  import { MusicPlayer } from "./music-player/_helpers/music-player";
  import { ShortcutKeyHandler } from "./music-player/_helpers/shortcut-key-handler";
  import type { TitleDisplayElement } from "./music-player/title-display.astro.0.mts";
  import type { PlayControlElement } from "./music-player/play-control.astro.0.mts";
  import type { VolumeControlElement } from "./music-player/volume-control.astro.0.mts";
  import type { TempoControlElement } from "./music-player/tempo-control.astro.0.mts";
  import type { MusicTabulizerElement } from "./music-tabulizer.astro.0.mts";

  type State = "unloaded" | "loading" | "playing" | "paused";

  export type EventType = GuaranteedEvent | FallibleEvent;

  type GuaranteedEvent =
    | { type: "SET_VOLUME"; volume: number }
    | { type: "DOWN_VOLUME"; amount: number }
    | { type: "UP_VOLUME"; amount: number }
    | { type: "SET_TEMPO"; tempo: number }
    | { type: "DOWN_TEMPO"; amount: number }
    | { type: "UP_TEMPO"; amount: number }
    | { type: "PLAY" }
    | { type: "PAUSE" }
    | { type: "TOGGLE_PLAYING" }
    | { type: "SEEK_TO"; sec: number }
    | { type: "SEEK_BACKWARD"; secs: number }
    | { type: "SEEK_FORWARD"; secs: number }
    | { type: "TOGGLE_MUTE" };

  type FallibleEvent = { type: "LOAD"; music: Music };

  export class MusicPlayerElement extends HTMLElement {
    #musicTabulizer!: MusicTabulizerElement;

    #audioForMediaSession!: HTMLAudioElement;
    #titleDisplay!: TitleDisplayElement;
    #playControl!: PlayControlElement;
    #volumeControl!: VolumeControlElement;
    #tempoControl!: TempoControlElement;

    #musicPlayer = new MusicPlayer();
    #loadedMusic: Music | undefined;
    #updateDisplayRequestId = 0;
    #state: State = "unloaded";

    #media!: MediaSessionController;
    #shortcutKey!: ShortcutKeyHandler;

    connectedCallback() {
      this.#musicTabulizer = queryMusicTabulizer();

      this.#audioForMediaSession = this.querySelector("audio")!;
      this.#titleDisplay = this.querySelector(".title-display")!;
      this.#playControl = this.querySelector(".play-control")!;
      this.#volumeControl = this.querySelector(".volume-control")!;
      this.#tempoControl = this.querySelector(".tempo-control")!;

      this.#media = new MediaSessionController(this.#audioForMediaSession);
      this.#media.setActionHandler("play", () => {
        this.send({ type: "PLAY" });
      });
      this.#media.setActionHandler("pause", () => {
        this.send({ type: "PAUSE" });
      });

      this.#shortcutKey = new ShortcutKeyHandler(this);
      this.#shortcutKey.register();
    }

    disconnectedCallback() {
      this.#shortcutKey.unregister();
    }

    async send(event: GuaranteedEvent): Promise<void>;
    async send(event: FallibleEvent): Promise<boolean>;
    async send(event: EventType): Promise<void | boolean>;

    async send(event: EventType) {
      switch (this.#state) {
        case "unloaded":
          return await this.#unloaded(event);
        case "loading":
          return await this.#loading(event);
        case "playing":
          return await this.#playing(event);
        case "paused":
          return await this.#paused(event);
        default:
          throw new Error(`unknown state: ${this.#state satisfies never}`);
      }
    }

    // dispatchers per state

    async #unloaded(event: EventType) {
      switch (event.type) {
        case "LOAD":
          return await this.#load(event.music);
      }
    }

    async #loading(event: EventType) {
      switch (event.type) {
      }
    }

    async #playing(event: EventType) {
      switch (event.type) {
        case "PAUSE":
          return await this.#pause();
        default:
          return await this.#playingPausedShared(event);
      }
    }

    async #paused(event: EventType) {
      switch (event.type) {
        case "PLAY":
          return await this.#play();
        default:
          return await this.#playingPausedShared(event);
      }
    }

    // dispatchees

    async #load(music: Music) {
      const prevState = this.#state;
      this.#state = "loading";

      this.#disableAllControls();
      this.#pauseUI();
      this.#loadToUI(music);
      this.#media.loadMetadata(music);
      this.#loadedMusic = music;

      try {
        await this.#musicPlayer.load(music);
      } catch (e) {
        console.error(e);
        this.#state = prevState;
        return false;
      }

      this.#enableAllControls();

      this.#state = "paused";
      return true;
    }

    async #playingPausedShared(event: EventType) {
      switch (event.type) {
        case "LOAD":
          return await this.#load(event.music);
        case "SET_VOLUME":
          return this.#setVolume(event.volume);
        case "DOWN_VOLUME":
          return await this.#downVolume(event.amount);
        case "UP_VOLUME":
          return await this.#upVolume(event.amount);
        case "SET_TEMPO":
          return this.#setTempo(event.tempo);
        case "DOWN_TEMPO":
          return await this.#downTempo(event.amount);
        case "UP_TEMPO":
          return await this.#upTempo(event.amount);
        case "TOGGLE_PLAYING":
          return await this.#togglePlaying();
        case "SEEK_TO":
          return await this.#seekTo(event.sec);
        case "SEEK_BACKWARD":
          return await this.#seekBackward(event.secs);
        case "SEEK_FORWARD":
          return await this.#seekForward(event.secs);
        case "TOGGLE_MUTE":
          return this.#toggleMute();
      }
    }

    #setVolume(volume: number) {
      this.#musicPlayer.volume = volume;
      this.#volumeControl.volume = volume;
      this.#loadedMusic?.updateSettings({ volume });
    }

    async #downVolume(amount: number) {
      const { min, volume } = this.#volumeControl;
      const newVolume = Math.max(min, volume - amount);
      return await this.send({ type: "SET_VOLUME", volume: newVolume });
    }

    async #upVolume(amount: number) {
      const { max, volume } = this.#volumeControl;
      const newVolume = Math.min(max, volume + amount);
      return await this.send({ type: "SET_VOLUME", volume: newVolume });
    }

    #setTempo(tempo: number) {
      this.#musicPlayer.tempo = tempo;
      this.#tempoControl.tempo = tempo;
      this.#loadedMusic?.updateSettings({ tempo });
    }

    async #downTempo(amount: number) {
      const { min, tempo } = this.#tempoControl;
      const newTempo = Math.max(min, tempo - amount);
      return await this.send({ type: "SET_TEMPO", tempo: newTempo });
    }

    async #upTempo(amount: number) {
      const { max, tempo } = this.#tempoControl;
      const newTempo = Math.min(max, tempo + amount);
      return await this.send({ type: "SET_TEMPO", tempo: newTempo });
    }

    async #play() {
      await this.#musicPlayer.play();
      this.#musicTabulizer.toPlaying(this.#loadedMusic!);
      this.#playControl.toPlaying();
      this.#media.toPlaying();
      this.#startUpdateCurrentTime();
      this.#state = "playing";
    }

    async #pause() {
      await this.#musicPlayer.pause();
      this.#musicTabulizer.toPaused(this.#loadedMusic!);
      this.#playControl.toPaused();
      this.#media.toPaused();
      this.#stopUpdateCurrentTime();
      this.#state = "paused";
    }

    async #togglePlaying() {
      switch (this.#state) {
        case "paused":
          return await this.send({ type: "PLAY" });
        case "playing":
          return await this.send({ type: "PAUSE" });
      }
    }

    async #seekTo(sec: number) {
      await this.#musicPlayer.seekTo(sec);
      this.#playControl.time = sec;
    }

    async #seekBackward(secs: number) {
      const { min, time } = this.#playControl;
      const sec = Math.max(min, time - secs);
      return await this.send({ type: "SEEK_TO", sec });
    }

    async #seekForward(secs: number) {
      const { max, time } = this.#playControl;
      const sec = Math.min(max, time + secs);
      return await this.send({ type: "SEEK_TO", sec });
    }

    #toggleMute() {
      this.#musicPlayer.toggleMute();
      this.#volumeControl.toggleIcon();
    }

    // helpers

    #disableAllControls() {
      this.#playControl.disable();
      this.#volumeControl.disable();
      this.#tempoControl.disable();
    }

    #enableAllControls() {
      this.#playControl.enable();
      this.#volumeControl.enable();
      this.#tempoControl.enable();
    }

    #pauseUI() {
      this.#playControl.toPaused();
      this.#stopUpdateCurrentTime();
    }

    #loadToUI(music: Music) {
      this.#titleDisplay.load(music);
      this.#playControl.load(music);
      this.#volumeControl.load(music);
      this.#tempoControl.load(music);
    }

    #startUpdateCurrentTime() {
      this.#updateDisplayRequestId = requestAnimationFrame(this.#updateCurrentTime);
    }

    #stopUpdateCurrentTime() {
      cancelAnimationFrame(this.#updateDisplayRequestId);
    }

    #updateCurrentTime = () => {
      this.#playControl.time = this.#musicPlayer.currentTime ?? 0;
      this.#updateDisplayRequestId = requestAnimationFrame(this.#updateCurrentTime);
    };
  }

  if (!customElements.get("music-player")) {
    customElements.define("music-player", MusicPlayerElement);
  }
</script>

<style>
  music-player {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
  }

  .volume-and-tempo {
    display: flex;
    justify-content: space-between;
    gap: 1.125rem;
  }
</style>
